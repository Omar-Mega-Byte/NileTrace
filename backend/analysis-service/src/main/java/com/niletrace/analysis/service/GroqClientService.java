package com.niletrace.analysis.service;

import com.niletrace.analysis.dto.GroqChatRequest;
import com.niletrace.analysis.dto.GroqChatResponse;
import com.niletrace.analysis.dto.IncidentSnapshot;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.reactive.function.client.WebClientResponseException;
import reactor.util.retry.Retry;

import java.time.Duration;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.util.List;

/**
 * Client service for interacting with Groq LLM API.
 * Handles prompt engineering and API communication with retry logic.
 */
@Service
@Slf4j
@RequiredArgsConstructor
public class GroqClientService {

    private final WebClient groqWebClient;

    @Value("${groq.api.model:llama-3.1-70b-versatile}")
    private String model;

    @Value("${groq.api.temperature:0.3}")
    private double temperature;

    @Value("${groq.api.max-tokens:4096}")
    private int maxTokens;

    @Value("${groq.api.retry.max-attempts:3}")
    private int maxRetryAttempts;

    @Value("${groq.api.retry.delay-seconds:2}")
    private int retryDelaySeconds;

    private static final String SYSTEM_PROMPT = """
            You are an expert Site Reliability Engineer (SRE) and incident response specialist.
            Your task is to analyze incident logs and generate a comprehensive postmortem report.

            IMPORTANT GUIDELINES:
            1. Be concise but thorough
            2. Focus on actionable insights
            3. Use technical language appropriate for engineering teams
            4. Base your analysis ONLY on the provided log content and incident context
            5. If information is insufficient, clearly state what additional data would be helpful
            6. Do not make up specific timestamps or details not present in the logs
            7. Note that some PII may have been redacted (marked as [TYPE_REDACTED]) - this is expected

            OUTPUT FORMAT:
            You MUST respond with a properly formatted Markdown document following the exact template structure provided.
            Do not add any sections not specified in the template.
            Do not include any preamble or explanation outside the markdown structure.
            """;

    private static final String REPORT_TEMPLATE = """

            Generate a postmortem report using EXACTLY this structure:

            # Executive Summary
            [High-level explanation of what happened and why it matters - 2-3 sentences]

            ## Incident Timeline
            [Chronological sequence of key events - use bullet points with timestamps if available]

            ## Root Cause Analysis
            [Primary root cause and contributing factors - be specific and technical]

            ## Impact Assessment
            [Who and what was affected, and for how long - quantify if possible]

            ## Resolution Steps
            [Actions taken to restore service - numbered list]

            ## Lessons Learned
            [Process, tooling, or architectural gaps discovered - bullet points]

            ## Action Items
            - [ ] Short-term remediation
            - [ ] Long-term prevention
            - [ ] Monitoring improvements

            ---
            *Generated by NileTrace Analysis Service*
            """;

    private static final DateTimeFormatter FORMATTER = DateTimeFormatter
            .ofPattern("yyyy-MM-dd HH:mm:ss z")
            .withZone(ZoneId.of("UTC"));

    /**
     * Generates a postmortem report by calling the Groq LLM API.
     *
     * @param snapshot            The sanitized incident snapshot
     * @param sanitizedLogContent The PII-scrubbed log content
     * @return Generated markdown report
     */
    public String generatePostmortemReport(IncidentSnapshot snapshot, String sanitizedLogContent) {
        String userPrompt = buildUserPrompt(snapshot, sanitizedLogContent);

        log.info("Calling Groq API for incident {} with model {}", snapshot.getIncidentId(), model);

        GroqChatRequest request = GroqChatRequest.builder()
                .model(model)
                .temperature(temperature)
                .max_tokens(maxTokens)
                .messages(List.of(
                        GroqChatRequest.Message.builder()
                                .role("system")
                                .content(SYSTEM_PROMPT)
                                .build(),
                        GroqChatRequest.Message.builder()
                                .role("user")
                                .content(userPrompt)
                                .build()))
                .build();

        try {
            GroqChatResponse response = groqWebClient.post()
                    .uri("/chat/completions")
                    .bodyValue(request)
                    .retrieve()
                    .bodyToMono(GroqChatResponse.class)
                    .retryWhen(Retry.backoff(maxRetryAttempts, Duration.ofSeconds(retryDelaySeconds))
                            .filter(this::isRetryableException)
                            .doBeforeRetry(signal -> log.warn("Retrying Groq API call, attempt {}",
                                    signal.totalRetries() + 1)))
                    .block(Duration.ofSeconds(120));

            if (response == null || response.getChoices() == null || response.getChoices().isEmpty()) {
                throw new RuntimeException("Empty response from Groq API");
            }

            String content = response.getChoices().get(0).getMessage().getContent();
            log.info("Successfully generated report for incident {}. Tokens used: {}",
                    snapshot.getIncidentId(),
                    response.getUsage() != null ? response.getUsage().getTotal_tokens() : "unknown");

            return content;

        } catch (WebClientResponseException e) {
            log.error("Groq API error for incident {}: {} - {}",
                    snapshot.getIncidentId(), e.getStatusCode(), e.getResponseBodyAsString());
            throw new RuntimeException("Groq API call failed: " + e.getMessage(), e);
        } catch (Exception e) {
            log.error("Error generating report for incident {}: {}", snapshot.getIncidentId(), e.getMessage());
            throw new RuntimeException("Failed to generate postmortem report: " + e.getMessage(), e);
        }
    }

    private String buildUserPrompt(IncidentSnapshot snapshot, String sanitizedLogContent) {
        StringBuilder prompt = new StringBuilder();

        prompt.append("## INCIDENT CONTEXT\n\n");
        prompt.append("**Incident ID:** ").append(snapshot.getIncidentId()).append("\n");
        prompt.append("**Title:** ").append(snapshot.getTitle()).append("\n");
        prompt.append("**Description:** ").append(snapshot.getDescription()).append("\n");
        prompt.append("**Severity:** ").append(snapshot.getSeverity()).append("\n");
        prompt.append("**Incident Start Time:** ").append(FORMATTER.format(snapshot.getIncidentStartTime()))
                .append("\n");
        prompt.append("**Created At:** ").append(FORMATTER.format(snapshot.getCreatedAt())).append("\n");

        // Add optional context if available
        if (snapshot.getServiceName() != null && !snapshot.getServiceName().isBlank()) {
            prompt.append("**Service:** ").append(snapshot.getServiceName()).append("\n");
        }
        if (snapshot.getEnvironment() != null && !snapshot.getEnvironment().isBlank()) {
            prompt.append("**Environment:** ").append(snapshot.getEnvironment()).append("\n");
        }
        if (snapshot.getRegion() != null && !snapshot.getRegion().isBlank()) {
            prompt.append("**Region:** ").append(snapshot.getRegion()).append("\n");
        }

        prompt.append("\n## LOG CONTENT (PII Redacted)\n\n");
        prompt.append("```\n");
        prompt.append(truncateIfNeeded(sanitizedLogContent, 15000)); // Limit log content for API limits
        prompt.append("\n```\n");

        prompt.append(REPORT_TEMPLATE);

        return prompt.toString();
    }

    private String truncateIfNeeded(String content, int maxLength) {
        if (content == null) {
            return "";
        }
        if (content.length() <= maxLength) {
            return content;
        }
        log.warn("Log content truncated from {} to {} characters", content.length(), maxLength);
        return content.substring(0, maxLength) + "\n\n[... LOG TRUNCATED DUE TO SIZE LIMIT ...]";
    }

    private boolean isRetryableException(Throwable throwable) {
        if (throwable instanceof WebClientResponseException e) {
            int status = e.getStatusCode().value();
            // Retry on 429 (rate limit), 500, 502, 503, 504
            return status == 429 || status >= 500;
        }
        return false;
    }
}
